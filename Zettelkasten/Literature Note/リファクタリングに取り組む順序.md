tags:
	#literature 
	#refactoring 
	#cognitive-load 
source:
	[[リファクタリングの第一歩──変数宣言を参照箇所へ近づけて認知負荷を下げる]]
	OpenAI o3

---
# Q&A
## Q1.
リファクタリングは“細部（ローカル）からか”、“大きなまとまり（モジュール／アーキテクチャ）からか”、どちらから取り組むべきか?

### A1.
「リファクタリングは“細部（ローカル）からか”“大きなまとまり（モジュール／アーキテクチャ）からか”」という問いは、実際には

1. いまコードベースにどれだけ守り（テスト）があるか
2. 変更目的が「負債の返済」なのか「新機能の下地作り」なのか
3. チーム内の合意形成コストをどれだけ払えるか

という三つの軸で決まります。  
最も事故が少ない一般的なセオリーは

A. 小さく安全なリファクタリング（マイクロ）で“土台を固める”  
B. そのうえで必要に応じて構造レベル（マクロ）のリファクタリングへ進む

という二段ロケット方式です。

## Q2.
小さなリファクタリングを先に行うべき理由は?

### A2.
* フィードバックループが速い  
	～３行の移動／名前変更だけなら、単体テストとレビューが瞬時に終わる  
* コンパイルエラーやユニットテスト失敗が局所的  
	失敗時に “どの変更が原因か” を特定しやすい  
* 認知負荷を下げて「どこをどう大きく変えたいか」が見えやすくなる  
* ブランチの寿命が短く、マージ競合リスクが小さい  
* チームが“大きな方針転換”を受け入れる心構えを作れる  
	 「毎日ちょっとずつ良くなる」実感は合意形成に効く

## Q3.
どこまで小さく刻むか?

### A3.
マイクロ refactoring チェックリスト

* 変数スコープを縮める・不要変数を削除
*  暗黙の副作用を関数名・型に明示 (rename・type annotation)  
*  ループを⼀時変数なしの `sum`, `any`, `all`, `max` などへ置換  
*  “ダックタイピング”→プロトコルクラス／抽象基底クラスで明示  
*  疑似グローバル（設定・状態）を `Context` オブジェクトに包む  
*  条件分岐の畳み込み (early return／guard clause)
	
これらは１ PR ≤ 数十行 で済み、CI が赤くなっても即座に戻せます。

## Q4.
テストがない／薄い場合は？  

### A4.
* Michael Feathers の “最小のテスト挿入口 (Seam) を作る → テストを書く → 安心して小リファクタリング”  
* テストを書けるだけのスキマを作るのも立派な micro-refactoring  
* どうしても作れない場合は「振る舞いベースの高レベル自動テスト」を先に用意し、“黒箱ガード”としておく

## Q5.
いつ“大きな構成変更”に踏み切るか

### A5.
次の条件がそろったらマクロ refactoring を検討します。

1. Critical mass: “ここより先はディレクトリ構成を変えないと無理”という痛みの量が十分
2. Safety net: 自動テストで主要ユースケースが落ちない
3. Migration plan: ストラングラーパターン、Branch by Abstraction などで段階移行できる見通し
4. Buy-in: ステークホルダー（同僚・PM・SRE 等）がスプリント単位で時間を確保済み

## Q6.
マクロrefactoringの典型的なフェーズは?

### A6.
Step 0 ブラウンフィールドを可視化（依存グラフ、メトリクス）  
Step 1 “機能単位”のサブディレクトリ／パッケージへ Move Class / Move Module  
Step 2 ドメイン境界を越える依存を Facade / Gateway に隔離  
Step 3 中核ドメイン → 外部サービスの切り離し（Hexagonal / Clean Architecture 化）  
Step 4 レイヤリングが整ったら、マイクロサービスや Plugin 方式へ分割

いずれも「動くソフトウェアを常にリリース可能な状態で保つ」ことが最優先です。

## Q7.
リファクタリングの典型的な実施順は?

### A7.
以下のような“積み上げパス”が王道です。

1. 変数スコープ短縮・命名改善（数分）
2. 関数抽出・メソッド抽出（数分～数時間）
3. 関連メソッドをクラスへ集約（Extract Class）（数時間）
4. 機能ごとにパッケージ移動（Move Module）（½～1 スプリント）
5. 新アーキテクチャ層に Facade を追加し、既存呼び出しを段階移行（複数スプリント）
  
## まとめ   
* リファクタリングは「小さく刻んで安全網を整えてから、大きく動かす」のが失敗しにくい  
* 小手先の掃除が“本丸の構造変革”の下準備になる  
* ただしテストが厚く、チームが合意しているなら最初からマクロに着手しても良い  
* その場合でも“テストが光るまでに壊す行数”を最小化する方針は不変

小さめの成功体験を短いサイクルで積み上げることが、  
大規模リファクタリング成功への最短ルートです。

## 補足
A3.
>疑似グローバル（設定・状態）を `Context` オブジェクトに包む  

とは、どのような実装か?
[[疑似グローバル変数に関するリファクタリング]]


A4.
>* Michael Feathers の “最小のテスト挿入口 (Seam) を作る → テストを書く → 安心して小リファクタリング”  

とは、何か?
[[Michael Feathers の “最小のテスト挿入口 (Seam)]]