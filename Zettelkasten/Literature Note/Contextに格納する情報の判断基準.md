tags:
	#literature 
	#refactoring 
	#unit-test 
	#testability 
source:
	[[疑似グローバル変数に関するリファクタリング]]
	OpenAI o3

---
# Q&A
## Q1.
疑似グローバル（module scope 変数やシングルトンオブジェクト）を直接読むコードを
リファクタリングする際に、Contextを使用し、共有設定・状態を１つのデータ構造に集約する。
Contextに格納する情報の判断基準は?

### A1.
関数にとって、「本質的に要らない値」かどうかできまる。

「本質的に要らない値」は、ひと言でいうと

その値が変わっても  
1. その関数の振る舞い（戻り値・副作用）が変わらない  
2. その関数内部で直接参照・判定・計算に使われない

──にもかかわらず、“とりあえず Context に入って流れ込んでいる”ような値です。  
以下の４つの観点で判定すると見つけやすくなります。

1. 直接利用しているか？
* 使っていない（IDE で unused import / unused attribute の警告が出る）
* ただ次の関数へ丸投げしているだけ（Pass-through 引数）  
    丸投げ元と丸投げ先のあいだに **Facade** や **Repository** を置けば不要

例
- `calc_discount(price, ctx)` が `ctx.logger` を一度も呼ばなければ  
    `logger` は本質的に不要
- ドメイン計算で `ctx.db` を渡しているが、実際は取得済み値しか使わない

2. その値が変わる可能性はあるか？ 
* 全環境で一定（ハードコード同然）の定数
	──関数内で定数宣言すれば済む  
* 呼び出し階層で固定されていて“関数境界を跨いで変わる余地がない”
	──引数にする必然性がない 
* 容易に導出できる派生値
	──例：`ctx.base_url` と `endpoint` があれば  
	`f"{ctx.base_url}/{endpoint}"` を作れるので  
	`full_url` を Context に保持するのは冗長

3. 後続のテスト／モックで本当に差し替えたい値か？ 
* テストで差し替える必要がなければ、Context ではなく
  普通のモジュール定数 or デフォルト引数で良い  
* 差し替え方が「値」ではなく「振る舞い」なら
  Strategy パターン（コールバック関数）のほうが適切

3. 責務の粒度に合っているか？ 
* ドメインロジックにインフラ実装を混ぜていないか  
	──`EmailSender` や `PaymentGateway` が丸ごと入っていると
	関数単体テストで重い依存をモックする羽目になる  
* 逆に、インフラ層の関数がドメイン固有値を持ち込んでいないか  
	──例：HTTP クライアント関数が `ctx.user_id` を要求するのは過剰結合

まとめ：不要値チェックリスト
1. 「Ctrl+F」でその属性が本当に参照されているか確認
2. 参照していても“使うのは１行だけ”なら  
    → その１行を小関数化して、値の生成元で呼ぶ
3. 参照しておらず、テスト差替えも不要  
    → Context から削除
4. 参照はしているが丸投げなだけ  
    → 中間 Facade／Repository を作る
5. 参照しているが関数のレイヤと合っていない  
    → 依存逆転（インターフェース注入）へ設計を見直し

こうして「関数が論理的に必要としない値」を Context から排除すると、  
Context の肥大化を防ぎつつ、依存が明示的なスリムなコードを保てます。

## Q2.
>* 全環境で一定（ハードコード同然）の定数
	──関数内で定数宣言すれば済む  

とあるが、全環境で一括で変えたくなることはないのか?

### A2.
「全環境で一定（ハードコード同然）の定数」は  
“将来ぜったい変わらない”と宣言しているわけではなく、

「少なくとも“現時点”では、  
本番／開発／テスト／ローカルなど **すべての実行環境で同じ値** を持つ」

という意味です。
そのような値をわざわざ Context に混ぜ込むと、次のコストが発生します。

1. どの関数でも `ctx.xxx` を受け取るシグネチャ拡張が必要
2. テストごとに **無意味な初期化** を書くはめになる
3. 実際に変えたくなったとき“Context を作る全呼び出し箇所”を修正する羽目になる

逆に「将来、環境ごとに一括で変えたい」可能性が少しでもあるなら、  
関数内にベタ書きではなく **モジュール定数** や **設定ファイル** に切り出しておくと良い、  
という整理になります。

## Q3.
どこに定義を配置するかの判断基準は?

### A3.
どこに置くかを決める２軸

1. 変化の“頻度”  
    • ５年に 1 回変わるかもしれない → モジュール定数で十分  
    • 四半期に 1 回は数値をチューニング → 設定ファイル／環境変数
    
2. 変化の“粒度”  
    • すべての環境で同時に同じ値へ変える → モジュール定数  
    • 環境ごとに値が異なる or A/B テストで切り替える → Context / DI
    

この２軸でグラフを描くと、Context へ入れるべき値は  
「頻繁に、かつ環境ごとに変わる」ゾーンに集中します。

実際のコード例
1. “ほぼ不変”な定数：モジュール直下で OK

settings.py
```python
# 10年放置でも困らないレベルの定数
MAX_USERNAME_LEN = 30
```

validators.py
```python
from .settings import MAX_USERNAME_LEN

def validate_username(name: str) -> bool:
    return 0 < len(name) <= MAX_USERNAME_LEN
```

2. “環境ごとに変わる”が **今は１種類しか要らない** 場合  
	→ まずはモジュール定数 + 環境変数読み込みで十分

settings.py
```python
import os

TIMEOUT_SEC = int(os.getenv("TIMEOUT_SEC", 3))  # 変えたいときは env を渡す
```

将来「リクエスト単位で動的に変えたい」要件が来たら  
この TIMEOUT_SEC を Context に格上げする、という **段階的リファクタリング** が可能です。  
（呼び出しコードは `settings.TIMEOUT_SEC` → `ctx.timeout_sec` に置換すれば済む）

## Q4.
“あとで一括変更したくなった”ときは、どのように対応する?

### A4.
1. **モジュール定数 → Context** への昇格自体は機械的置換で済む  
    – だから「最初から全部 Context に詰め込む」よりも  
    “必要になったら昇格”のほうがトータル変更行数が減る
    
2. その際に  
    • 依存分析ツール（pyan、pydeps、IDE の Call Hierarchy）で  
    どの関数が定数を読んでいるかリストアップ  
    • `sed` / `ripgrep --json` / `refactor` プラグインで一括置換  
    とすれば、作業コストは多くの場合数十分程度です。

## まとめ
* 全環境で共通の値は「モジュール定数 or 設定ファイル」にまず置く  
* **“将来変わるかも”だけを根拠に Context へ入れるのは YAGNI** に近い  
* 実際に環境差分やリクエスト差分が必要になった段階で
  モジュール定数を Context フィールドへ“昇格”すればよい  
	– 昇格は自動置換で機械的にできる → 今のシンプルさを保つほうが得

この判断基準をチームで共有しておけば、  
“Context が無駄に肥大化して追跡しづらい”状態を防ぎつつ、  
「全環境で一括変更したい」という要件にも柔軟に対応できます。