tags:
	#literature 
	#refactoring 
	#unit-test
	#testability
source:
	[[リファクタリングに取り組む順序]]
	OpenAI o3

---
# Q&A
## Q1.
疑似グローバル（module scope 変数やシングルトンオブジェクト）を直接読むコードが
散らばっている問題点は?

### A1.
疑似グローバル（module scope 変数やシングルトンオブジェクト）を直接読むコードが散らばっていると、  
テスト・並行実行・設定変更時に次のような痛みが出ます。

* 振る舞いが環境に縛られるため“再現手順”が複雑になる  
* テストで値をモンキーパッチすると、並列テストが互いに汚染し合う  
* 開発／本番で値を書き換えるために if DEBUG などの分岐が増殖する  
* 依存関係が暗黙になるので IDE の参照検索や型チェックが効きにくい

そこで「Context オブジェクトに包む」＝  
「共有設定・状態を１つのデータ構造に集約し、呼び出し側へ“明示的に”渡す」  
という手法が有効です。

## Q2.
基本パターンは?

### A2.
1. 典型的な“疑似グローバル”コード

config.py
```python
API_URL = "https://api.example.com"
TIMEOUT_SEC = 3
```

service.py
```python
import requests
from .config import API_URL, TIMEOUT_SEC      # ← 直接 import している

def fetch_user(uid: str):
    resp = requests.get(f"{API_URL}/users/{uid}", timeout=TIMEOUT_SEC)
    resp.raise_for_status()
    return resp.json()
```

テスト時に `config.API_URL = "http://stub"` と書き換えると、  
他テストと衝突する・並列実行できない、などの問題が発生しがちです。

2. Context オブジェクトに包む

context.py
```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Context:
    api_url: str
    timeout_sec: int
```

service.py
```python
import requests
from .context import Context

def fetch_user(uid: str, ctx: Context):
    resp = requests.get(f"{ctx.api_url}/users/{uid}", timeout=ctx.timeout_sec)
    resp.raise_for_status()
    return resp.json()
```

main.py
```python
from .context import Context
from .service import fetch_user

def main():
    ctx = Context(api_url="https://api.example.com", timeout_sec=3)
    print(fetch_user("42", ctx))

if __name__ == "__main__":
    main()
```

テスト側は次のように**完全に独立**した設定を持てます。

test_service.py
```python
from sample.after.context import Context
from sample.after.service import fetch_user
from pytest_httpserver import HTTPServer

def test_fetch_user(httpserver: HTTPServer):
    httpserver.expect_request("/users/42").respond_with_json({"name": "zed"})
    ctx = Context(api_url=httpserver.url_for(""), timeout_sec=1)
    user = fetch_user("42", ctx)
    assert user["name"] == "zed"
```

## Q3.
Context に入れるべきもの・入れないほうがよいものは?

### A3.
入れると効果が高い
* **環境ごとに変わる設定値**（URL、タイムアウト、APIキー、ログレベル）  
* **疎結合にしたい副作用オブジェクト**（DB 接続、メッセージキュー、トレーサ）  
* **リクエスト単位で変わる状態**（ユーザ ID、トランザクション ID、ロケール）

避けたほうがいい
* 関数が本質的に要らない値（不要情報が増えると Context が肥大化）  
* シーケンス番号など“逐次書き換えるミュータブル値”  
	どうしても必要ならカウンタオブジェクトを分離して渡す