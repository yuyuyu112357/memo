tags:
	#literature 
	#refactoring 
	#cognitive-load 
source:
	[[リファクタリングで最初にすることは？]]
	OpenAI o3

---
# Q&A
## Q1.
リファクタリングで最初に取り組むべきことは何でしょうか?
変数の定義(C言語でいうところの初期化)位置をその変数の参照箇所の近くへ、
移動させ、コードを読むときの認知負荷を下げることではないでしょうか?

### A1.
リファクタリングに着手する順番に「唯一絶対の正解」はありませんが、実務で失敗しにくく、後続のステップ（関数抽出・責務分割・設計改善など）の成功確率を高める“安全な第一歩”は次の２点に集約できます。

1. 変数のスコープ（有効範囲と生存期間）を極力 “狭く” する
2. 変数・関数・クラスの名前を「意図が読める名前」へリネームする

## Q2.
変数のスコープ（有効範囲と生存期間）を極力 “狭く” する理由は?

### A2.
 * 認知負荷が劇的に下がる
	 * 目を上下に行き来せずに「値の由来」が即座に分かる
	 * if／ループの終了位置まで読み進めなくても、副作用の有無を判断できる
* スコープが狭くなれば「副作用が閉じ込められたミニ領域」が可視化される
	* その領域を丸ごと関数抽出（Extract Function）しやすい
* 静的解析ツールや IDE の「未使用変数」「定数化可能」の警告が当たりやすくなる
* 後続のリネームや型付け（Type Annotation）も局所的に済むため、コンパイルエラー／テスト失敗の修正コストが低い

## Q3.
リファクタリング手順（変数スコープ縮小）は?

### A3.
1. 変数を読む側・書く側の最小集合を探す
2. 代入（初期化）ステートメントを 1. で特定した最初の読み取りの直前へ移動
3. `const`/`final`/型アノテーションを付与できないか検討
4. ループ・分岐ブロックをまたがないなら、内側へ移動
5. どうしても大域的な変数が必要な場合は、それが「副作用を管理するオブジェクト」であることを明示（例：Context, Repository, Gateway などに包む）

Before
```python
def build_report():
    # “とりあえず上に全部まとめて書いた”パターン
    report = None
    raw = None
    f = open("sales.csv")           # ← 副作用が早すぎる
    lines = f.readlines()
    f.close()

    # 集計処理
    total = 0
    for line in lines:
        price = int(line.split(",")[1])
        total += price

    # レンダリング
    report = f"total sales = {total}"
    return report

```

After
```python
def build_report():
    # 入出力は最小スコープに閉じ込める
    with open("sales.csv") as f:
        lines = f.readlines()

    total = sum(int(line.split(",")[1]) for line in lines)
    return f"total sales = {total}"

```

改善ポイント  
* ファイルハンドラ `f` の寿命が with ブロック内に限定され、リークの危険が消える  
* 変数 `total`・`lines` も不要になれば即スコープ外へ出て GC 対象になる  
* `sum(...)` により集計処理が１行に凝縮され、次のリファクタリング候補（別関数化）が明確

## Q4.
スコープを極力、狭くしてはいけない、例外パターンは?

### A4.
スコープを動かしてはいけない代表的ケース 
* ファイル生成／削除、DB トランザクション開始／終了など、処理順序が厳密に
  決まっている副作用をハンドリングする変数  
* ロックオブジェクト、セマフォなどスレッド同期を制御する変数  
* 参照透過性を壊すとテストが書きにくくなる RNG（乱数生成器）、時刻取得オブジェクト

これらは「スコープを狭める」より先に「副作用を表す型で包んで意図を明示する」ことが大切です。

## Q5.
「ループ・分岐ブロックをまたがないなら、内側へ移動」とは、何でしょうか?

### A5.
“その変数を最後に参照する行” がループや if‐else のブロック外にない場合、  
宣言（＝初期化）もブロックの内側へ押し込めてしまおう、という原則です。

⟩ 効果  
* 外側スコープが汚れず、読み手は「この変数はここで完結する」と一目で分かる  
* ブロック終了と同時に寿命が切れるため、誤用・再利用バグが起きにくい  
* IDE の変数名補完候補が減り、検索・リネーム対象も局所化される  
* 静的解析ツールが「未使用・初期化漏れ」を正確に検出できる

#### 【1】ループのケース
```python
def find_first_even(nums):
    result = None          # ← 外側にあるため「いつまで生きる？」が曖昧
    for n in nums:
        if n % 2 == 0:
            result = n
            break
    return result

```
↓
```python
def find_first_even(nums):
    for n in nums:
        if n % 2 == 0:
            return n       # ← 変数すら不要になった
    return None

```

ポイント  
* `result` がループ外で使われないと分かった瞬間、変数ごと削除できた  
* 返り値を直接 `return` すれば「ここでロジックが終わる」と明示できる  
* もし複数値を返すなら、ループ内でタプルや dataclass に詰めて return する

#### 【2】分岐 (if‐else) のケース
```python
def label_score(score):
    label = ""                          # ← 先に空文字を用意
    if score >= 80:
        label = "excellent"
    elif score >= 60:
        label = "good"
    else:
        label = "poor"
    return label

```
↓
```python
def label_score(score):
    if score >= 80:
        return "excellent"
    if score >= 60:
        return "good"
    return "poor"

```

改善点  
* `label` の“未定値”期間がなくなり、代入漏れバグが消える  
* if‐else ネストが浅くなるため、複雑度 (cognitive complexity) が下がる

#### 【3】「ループごとに初期化」が必要なケース

初期化をループ外へ出すとかえってバグる例を示します。
```python
import re

def extract_emails(texts):
    regex = re.compile(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}")
    matches = []                      # ← ループ外で再利用してしまう
    for t in texts:
        matches += regex.findall(t)
    return matches

```

上記は動きますが、`matches` をループ外に置いたせいで  
「各テキストのメール数」を同時に取りたい場合に困ります。

```python
import re

def extract_emails(texts):
    regex = re.compile(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}")
    per_text = []
    for t in texts:
        matches = regex.findall(t)    # ← ループ内で完結
        per_text.append(matches)
    return per_text

```

ここでは `matches` を毎周回で作り直したほうが  
「スコープが短い」「1 周回＝ 1 データ単位」の意図が明確、というメリットがあります。

#### 【4】注意すべきパターン（移動しないほうがよい）

1. 高コストな初期化（DB 接続、重い計算など）がループのたびに走り性能劣化
2. ループ外と内の両方で同じインスタンスを共有する必要がある
3. 複数の if‐else ブロックをまたいで値を累積する（集計変数、フラグ）

こうした場合は  
「変数を内側へ押し込めるか、そもそも責務を別関数に分けるか」  
をトレードオフで判断してください。

#### まとめ（判断フロー）

1. 変数を“最後に参照する行”を探す
2. その行がループ／分岐の内側なら、宣言も内側へ
3. 毎周回初期化コストが問題なら、外側に置く代わりに  
    ・遅延生成 (lazy)  
    ・ループ前でリスト内包表現や map/filter に置き換え  
    ・依存オブジェクトを渡し直す（DI）
4. スコープを縮めた後に「副作用を閉じ込める関数」へ抽出できないか検討

こうしてブロック単位でスコープを最小化すると、  
リファクタリングの“次の一手”が発見しやすくなります。
